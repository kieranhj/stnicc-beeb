STNICCC2000 for the Atari STe
https://www.pouet.net/prod.php?which=1251

File description: http://arsantica-online.com/st-niccc-competition/

The stream contains flags, palette-data and vertex-/polygon-data for 1800 frames.
The stream is segmented in 64KB blocks.
A frame never crosses such a 64KB boundary.
Polygons can have 3-15 vertices.
Polygons can cover each other, so a non-convex polygon filler is needed.
Polygons are rendered to a 256×200 pixel screen in 4 bit color depth.
The palette (16 out of 512 colors) can change from frame to frame.
Words are 2 bytes in big endian order.
Colors are stored as words in Atari-ST format 00000RRR0GGG0BBB (512 possible colors).

Every frame stores the following data:

1 byte Flags Bit 0: Frame needs to clear the screen.
Bit 1: Frame contains palette data.
Bit 2: Frame is stored in indexed mode.

If frame contains palette data
{
    1 word Bitmask

    For every set bit in the Bitmask (0-15)
    {
        1 word Color The color has to be copied into the palette at the reverse index of the actual bit,
        because the bitmask is stored in reverse order.
        In other words: If bit 15 of mask is set -> update color 0 of palette,
        …
        if bit 0 of mask is set -> update color 15 of palette.
    }
}

If frame is stored in indexed mode
{
    1 byte Number of vertices (0-255)

    For every Vertex
    {
        1 byte X-position
        1 byte Y-position
    }

    While (…)
    {
        1 byte Poly-descriptor Contains: hi-nibble – 4 bits color-index
        lo-nibble – 4 bits number of polygon vertices

        Some special cases are encoded in the descriptor byte:
        $ff = End of frame
        $fe = End of frame and the stream skips to the next 64KB block
        $fd = End of stream (we are done \o/)

        For every vertex of the polygon
        {
            1 byte Vertex-id (0-255)
        }
    }
}
Else if frame is stored in non-indexed mode
{
    while (…)
    {
        1 byte Poly-descriptor (See indexed mode)

        For every vertex of the polygon
        {
            1 byte X-position
            1 byte Y-position
        }
    }
}

Stats from Python parser
~~~
Total frames =  1800
Max polys =  164  on frame  0
Max verts =  220  on frame  3
Max poly size =  7  on frame  65
Total polys =  75340  average  41  polys/frame

Total byte = 639976 ~= 625K
Average bytes / frame ~= 356
Fast Amiga version runs it at about 17fps average
Presume original Atari version is about half that then!
Newer Atari versions run about 15fps
So 10fps would be extremely optimistic for Beeb!
Max data rate then 10*356 ~= 3.5k/s

Platform?
~~~
Should (just about) fit on a single ADFS L disc (640K)
Can read sector by sector from an ADFS disc.
Could also do this from a DFS disc but would require all 4x drives (total 800K)
Question now becomes whether to do this or not?
Depends if it is possible to get the streaming working and run the demo at the
same time.
Guess this is the same as the Bad Apple problem but without the music sync problem.
If want to make it available to as many people as possible, what's the best solution?

Master only would be the easiest - then just put it on an ADFS disc.
What would be needed to run on a Model B? Assuming everyone has tons of SWRAM.
I guess the streaming buffer size becomes the main question.
Probably going to be closer to 5fps than 10fps?

Debug ideas
~~~
Info pane:
- Frame #
- Vsync count
- Real time
- Any sort of poly stats
- FPS

Debug pane could be in MODE 4, single buffered, after the main window using vrup.
Single frame step on keypress.
Run to frame X (then single step).
Toggle solid / wireframe draw on paused frame.

Optimisations
~~~
First few frames take &34 = 52 vsyncs!!
These are 200+ verts and 160+ polys, each 3-4 sides.
Probably 500+ calls to drawline_into_span_buffer.
How many span calls?! 1600?!

Inside the tunnel is about &10 vsyncs..
Blocking load takes &10-&16 frames.

Unroll cls completely x2.
Don't copy verts into temp location (low)
Don't init span buffer every time - get span plot to set it back.
    - Saves 19 vsyncs!!! Now &21=33!

Simplify drawline_into_span_buffer code:
 - Self-mod INX/DEX and INY/DEY directly rather than branches. - DONE
 - Can we keep accumulator without having to store back to ZP?
 - Inline plot_pixel_into_span_buffer. - DONE
Possible to completely unroll Bresenham somehow?
 (Might need to duplicate the routine x4 but could be worth it?)

Put get_byte into ZP. - DONE

Plot span:
 - span_start should always be <= span_end w/ span buffer - DONE
 - Any coherency between calls to reduce start address calc?
 - Unroll long span plot - DONE
 - Divide width by 4 so can just dex - DONE (or remove altogether).
 - Any savings in plot_short_span? Inline plot_pixel_at? - DONE

Vsync on timer at line 200.
Frame swap on vsync.
Run ahead and block plot until swapped.

Only plot every other scanline?! What does this look like? - DONE

Optimisation progress:
 5/11 - first frame down to &1E=30 vsyncs
 5/11 - unrolled CLS a bit - down to &1D vsyncs
 7/11 - align to 7.5K, inline get_byte, inline pixel_plot - down to &1C vsyncs
 8/11 - unroll plot_short_span - down to &19 vsyncs!

Tidy up code
~~~
Move everything into separate modules in src/ - DONE
Add disk 2,1 & 3 - DONE
Build process for creating DSDs. - DONE
Test end-to-end. - DONE
Remove unnecessary DEFINEs.

Optimise plot_span
~~~
Not taking advantage of the fact that spans are contiguous in Y for many lines
Average 40 spans per poly..!

Compute writeptr as the start address on the line inc. scanline
Compute Y as column index

Think need to special case small spans of 2 bytes as seems to be a common case.

There are some incredibly small polys!
This gets worse when using half res. E.g. Frame 4:
     Polygon 3: Colour = 2 Num vertices = 3
        Vertices = [7, 8, 9]
          Edge 0 = [ 254, 98 ]
          Edge 1 = [ 255, 99 ]
          Edge 2 = [ 255, 98 ]
 Becomes co-incident point
 Worth culling these?
